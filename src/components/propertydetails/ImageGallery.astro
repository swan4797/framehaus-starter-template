---
// ========================================
// IMAGE GALLERY COMPONENT
// Lightbox gallery for property images
// With smooth fade transitions & thumbnail carousel
// ========================================

import type { PropertyMedia } from '../../types/database'

interface Props {
  images: PropertyMedia[]
  propertyAddress: string
  propertyId?: string
}

const { images, propertyAddress, propertyId } = Astro.props

// Sort by display order
const sortedImages = [...images]
  .filter(img => img.media_type === 'image')
  .sort((a, b) => a.display_order - b.display_order)

const hasImages = sortedImages.length > 0
const primaryImage = sortedImages[0]
---

<div class="property-gallery" data-property-id={propertyId}>
  {hasImages ? (
    <>
      <!-- Main Image -->
      <div class="main-image-container">
        <img
          src={primaryImage.file_url}
          alt={primaryImage.alt_text || `${propertyAddress} - Main Image`}
          class="main-image"
          id="main-image"
          data-index="0"
        />

        <!-- Image Counter -->
        <div class="image-counter">
          <span id="current-image">1</span> / {sortedImages.length}
        </div>

        <!-- Navigation Arrows (only if multiple images) -->
        {sortedImages.length > 1 && (
          <>
            <button
              class="nav-btn nav-btn--prev"
              id="prev-btn"
              aria-label="Previous image"
            >
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
              </svg>
            </button>
            <button
              class="nav-btn nav-btn--next"
              id="next-btn"
              aria-label="Next image"
            >
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
              </svg>
            </button>
          </>
        )}
      </div>

      <!-- Thumbnail Carousel -->
      {sortedImages.length > 1 && (
        <div class="thumbnail-carousel" data-total-images={sortedImages.length}>
          <button
            class="thumbnail-nav thumbnail-nav--prev"
            id="thumb-prev"
            aria-label="Previous thumbnails"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
            </svg>
          </button>

          <div class="thumbnail-track" id="thumbnail-track">
            <div class="thumbnail-slider" id="thumbnail-slider">
              {sortedImages.map((image, index) => (
                <button
                  class={`thumbnail ${index === 0 ? 'thumbnail--active' : ''}`}
                  data-index={index}
                  aria-label={`View image ${index + 1}`}
                >
                  <img
                    src={image.thumbnail_url || image.file_url}
                    alt={image.alt_text || `${propertyAddress} - Image ${index + 1}`}
                    loading="lazy"
                  />
                </button>
              ))}
            </div>
          </div>

          <button
            class="thumbnail-nav thumbnail-nav--next"
            id="thumb-next"
            aria-label="Next thumbnails"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      )}

      <!-- Lightbox Modal -->
      <div id="lightbox" class="lightbox">
        <button
          id="close-lightbox"
          class="lightbox__close"
          aria-label="Close lightbox"
        >
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>

        <button
          id="lightbox-prev"
          class="lightbox__nav lightbox__nav--prev"
          aria-label="Previous image"
        >
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        <button
          id="lightbox-next"
          class="lightbox__nav lightbox__nav--next"
          aria-label="Next image"
        >
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
          </svg>
        </button>

        <img
          id="lightbox-image"
          class="lightbox__image"
          src=""
          alt=""
        />

        <div class="lightbox__counter">
          <span id="lightbox-counter">1 / {sortedImages.length}</span>
        </div>
      </div>
    </>
  ) : (
    <div class="no-images">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>
      <p>No images available</p>
    </div>
  )}
</div>

<script define:vars={{ sortedImages, propertyId }}>
  // Gallery State
  let currentIndex = 0
  let isAnimating = false
  const images = sortedImages
  const propId = propertyId
  const FADE_DURATION = 250 // ms

  // Thumbnail carousel state
  let thumbnailPage = 0
  let visibleThumbnails = 8 // Default, will be calculated
  let maxThumbnailPages = 0

  // Elements
  const mainImage = document.getElementById('main-image')
  const currentImageSpan = document.getElementById('current-image')
  const prevBtn = document.getElementById('prev-btn')
  const nextBtn = document.getElementById('next-btn')
  const thumbnails = document.querySelectorAll('.thumbnail')

  // Thumbnail carousel elements
  const thumbnailTrack = document.getElementById('thumbnail-track')
  const thumbnailSlider = document.getElementById('thumbnail-slider')
  const thumbPrevBtn = document.getElementById('thumb-prev')
  const thumbNextBtn = document.getElementById('thumb-next')
  const thumbnailCarousel = document.querySelector('.thumbnail-carousel')

  // Lightbox
  const lightbox = document.getElementById('lightbox')
  const lightboxImage = document.getElementById('lightbox-image')
  const lightboxCounter = document.getElementById('lightbox-counter')
  const closeLightboxBtn = document.getElementById('close-lightbox')
  const lightboxPrev = document.getElementById('lightbox-prev')
  const lightboxNext = document.getElementById('lightbox-next')

  // Calculate visible thumbnails based on viewport
  function calculateVisibleThumbnails() {
    const width = window.innerWidth
    if (width <= 400) return 3
    if (width <= 640) return 4
    if (width <= 768) return 6
    return 8
  }

  // Initialize thumbnail carousel
  function initThumbnailCarousel() {
    visibleThumbnails = calculateVisibleThumbnails()
    maxThumbnailPages = Math.max(0, Math.ceil(images.length / visibleThumbnails) - 1)

    // Show/hide nav arrows based on total images
    const showNav = images.length > visibleThumbnails
    if (thumbnailCarousel) {
      thumbnailCarousel.setAttribute('data-show-nav', showNav.toString())
    }

    updateThumbnailNavigation()
    slideThumbnails(0) // Reset to first page
  }

  // Track image view
  function trackImageView(index) {
    if (window.StratosTracker && propId) {
      window.StratosTracker.trackEvent('image_gallery_view', {
        property_id: propId,
        image_index: index,
        image_count: images.length,
      })
    }
  }

  // Fade transition helper
  function fadeTransition(element, newSrc, newAlt, callback) {
    if (!element) return

    // Fade out
    element.classList.add('fade-out')

    setTimeout(() => {
      // Change image
      element.src = newSrc
      element.alt = newAlt

      // Wait for image to load, then fade in
      if (element.complete) {
        element.classList.remove('fade-out')
        if (callback) callback()
      } else {
        element.onload = () => {
          element.classList.remove('fade-out')
          if (callback) callback()
        }
      }
    }, FADE_DURATION)
  }

  // Get thumbnail dimensions
  function getThumbnailDimensions() {
    if (!thumbnails[0]) return { width: 72, gap: 8 }
    const thumb = thumbnails[0]
    const style = getComputedStyle(thumb)
    const width = thumb.offsetWidth
    const gap = parseFloat(style.marginRight) || 8
    return { width, gap }
  }

  // Slide thumbnails to show specific page
  function slideThumbnails(page) {
    if (!thumbnailSlider) return

    const { width, gap } = getThumbnailDimensions()
    const slideAmount = page * visibleThumbnails * (width + gap)
    thumbnailSlider.style.transform = `translateX(-${slideAmount}px)`
    thumbnailPage = page
    updateThumbnailNavigation()
  }

  // Scroll thumbnail carousel so active thumbnail is visible
  function ensureActiveThumbnailVisible(index) {
    const pageForIndex = Math.floor(index / visibleThumbnails)
    if (pageForIndex !== thumbnailPage) {
      slideThumbnails(pageForIndex)
    }
  }

  // Update thumbnail carousel navigation state
  function updateThumbnailNavigation() {
    if (!thumbPrevBtn || !thumbNextBtn) return

    // Disable prev if at first page
    thumbPrevBtn.disabled = thumbnailPage <= 0

    // Disable next if at last page
    thumbNextBtn.disabled = thumbnailPage >= maxThumbnailPages
  }

  // Update main image with fade
  function updateMainImage(index) {
    if (isAnimating || currentIndex === index) return
    isAnimating = true

    currentIndex = index

    if (mainImage && images[index]) {
      fadeTransition(
        mainImage,
        images[index].file_url,
        images[index].alt_text || `Image ${index + 1}`,
        () => {
          isAnimating = false
        }
      )
      mainImage.dataset.index = index.toString()
    }

    if (currentImageSpan) {
      currentImageSpan.textContent = (index + 1).toString()
    }

    // Update thumbnail active state
    thumbnails.forEach((thumb, i) => {
      if (i === index) {
        thumb.classList.add('thumbnail--active')
      } else {
        thumb.classList.remove('thumbnail--active')
      }
    })

    // Ensure active thumbnail is visible
    ensureActiveThumbnailVisible(index)

    trackImageView(index)
  }

  // Navigate
  function navigate(direction) {
    if (isAnimating) return
    const newIndex = direction === 'next'
      ? (currentIndex + 1) % images.length
      : (currentIndex - 1 + images.length) % images.length
    updateMainImage(newIndex)
  }

  // Navigate thumbnail carousel
  function navigateThumbnails(direction) {
    const newPage = direction === 'next'
      ? Math.min(thumbnailPage + 1, maxThumbnailPages)
      : Math.max(thumbnailPage - 1, 0)
    slideThumbnails(newPage)
  }

  // Open lightbox
  function openLightbox(index) {
    currentIndex = index
    if (lightbox && lightboxImage && images[index]) {
      lightboxImage.src = images[index].file_url
      lightboxImage.alt = images[index].alt_text || `Image ${index + 1}`
      lightbox.classList.add('lightbox--open')
      updateLightboxCounter()
      document.body.style.overflow = 'hidden'

      // Animate in
      requestAnimationFrame(() => {
        lightbox.classList.add('lightbox--visible')
      })

      if (window.StratosTracker && propId) {
        window.StratosTracker.trackEvent('lightbox_opened', {
          property_id: propId,
          image_index: index,
        })
      }
    }
  }

  // Close lightbox
  function closeLightbox() {
    if (lightbox) {
      lightbox.classList.remove('lightbox--visible')
      setTimeout(() => {
        lightbox.classList.remove('lightbox--open')
        document.body.style.overflow = ''
      }, 300)
    }
  }

  // Update lightbox counter
  function updateLightboxCounter() {
    if (lightboxCounter) {
      lightboxCounter.textContent = `${currentIndex + 1} / ${images.length}`
    }
  }

  // Navigate lightbox with fade
  function navigateLightbox(direction) {
    if (isAnimating) return
    isAnimating = true

    const newIndex = direction === 'next'
      ? (currentIndex + 1) % images.length
      : (currentIndex - 1 + images.length) % images.length
    currentIndex = newIndex

    if (lightboxImage && images[newIndex]) {
      fadeTransition(
        lightboxImage,
        images[newIndex].file_url,
        images[newIndex].alt_text || `Image ${newIndex + 1}`,
        () => {
          isAnimating = false
        }
      )
      updateLightboxCounter()
      trackImageView(newIndex)
    }
  }

  // Initialize thumbnail carousel
  initThumbnailCarousel()

  // Handle window resize
  let resizeTimeout
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout)
    resizeTimeout = setTimeout(() => {
      initThumbnailCarousel()
      ensureActiveThumbnailVisible(currentIndex)
    }, 150)
  })

  // Event Listeners - Main gallery
  if (prevBtn) prevBtn.addEventListener('click', () => navigate('prev'))
  if (nextBtn) nextBtn.addEventListener('click', () => navigate('next'))

  // Thumbnail click navigation
  thumbnails.forEach((thumb, index) => {
    thumb.addEventListener('click', () => updateMainImage(index))
  })

  // Thumbnail carousel navigation
  if (thumbPrevBtn) thumbPrevBtn.addEventListener('click', () => navigateThumbnails('prev'))
  if (thumbNextBtn) thumbNextBtn.addEventListener('click', () => navigateThumbnails('next'))

  // Main image click opens lightbox
  if (mainImage) {
    mainImage.addEventListener('click', () => {
      const index = parseInt(mainImage.dataset.index || '0')
      openLightbox(index)
    })
  }

  // Lightbox controls
  if (closeLightboxBtn) closeLightboxBtn.addEventListener('click', closeLightbox)
  if (lightboxPrev) lightboxPrev.addEventListener('click', () => navigateLightbox('prev'))
  if (lightboxNext) lightboxNext.addEventListener('click', () => navigateLightbox('next'))

  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    if (lightbox && lightbox.classList.contains('lightbox--open')) {
      if (e.key === 'ArrowLeft') navigateLightbox('prev')
      if (e.key === 'ArrowRight') navigateLightbox('next')
      if (e.key === 'Escape') closeLightbox()
    }
  })

  // Click outside to close lightbox
  if (lightbox) {
    lightbox.addEventListener('click', (e) => {
      if (e.target === lightbox) closeLightbox()
    })
  }

  // Touch/swipe support
  let touchStartX = 0
  let touchEndX = 0
  const SWIPE_THRESHOLD = 50

  function handleSwipe(element, onSwipeLeft, onSwipeRight) {
    element?.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX
    }, { passive: true })

    element?.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX
      const diff = touchStartX - touchEndX
      if (Math.abs(diff) > SWIPE_THRESHOLD) {
        if (diff > 0) {
          onSwipeLeft()
        } else {
          onSwipeRight()
        }
      }
    }, { passive: true })
  }

  // Add swipe to main image
  handleSwipe(mainImage, () => navigate('next'), () => navigate('prev'))

  // Add swipe to lightbox
  handleSwipe(lightboxImage, () => navigateLightbox('next'), () => navigateLightbox('prev'))
</script>

<style lang="scss">
  @use '../../styles/components/image-gallery';
</style>
